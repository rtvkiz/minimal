name: Build Hardened Images

on:
  push:
    branches: [main]
    paths:
      - 'python/**'
      - 'jenkins/**'
      - 'node/**'
      - 'go/**'
      - 'nginx/**'
      - 'httpd/**'
      - 'redis-slim/**'
      - 'postgres-slim/**'
      - '.github/workflows/build.yml'
  pull_request:
    branches: [main]
  schedule:
    # Rebuild daily at 2am UTC to get latest CVE patches
    - cron: '0 2 * * *'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  JENKINS_VERSION: "2.541.1"

jobs:
  #----------------------------------------------------------------------------
  # PYTHON IMAGE (Wolfi package + apko, shell-less)
  #----------------------------------------------------------------------------
  build-python:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install apko
        run: |
          go install chainguard.dev/apko@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Setup cosign
        uses: sigstore/cosign-installer@v3

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Python image with apko
        run: |
          apko build python/apko/python.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-python:${{ github.sha }} \
            python.tar \
            --arch x86_64
          docker load < python.tar
          LOADED_IMAGE=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep minimal-python | head -1)
          docker tag "$LOADED_IMAGE" ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-python:${{ github.sha }}

      - name: Report image size
        run: |
          echo "## Python Image Size" >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | \
            grep minimal-python >> $GITHUB_STEP_SUMMARY || true

      - name: Scan Python image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-python:${{ github.sha }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          exit-code: '0'
          cache: 'false'

      - name: Fail on CVEs
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-python:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-python.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
          cache: 'false'

      - name: Upload scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'trivy-python.sarif'

      - name: Test Python image
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-python:${{ github.sha }}"
          echo "Testing Python interpreter..."
          docker run --rm "$IMAGE" -c "import sys; print(f'Python {sys.version}')"
          echo "Testing TLS/SSL..."
          docker run --rm "$IMAGE" -c "import ssl; print('TLS OK:', ssl.OPENSSL_VERSION)"
          echo "Testing stdlib modules..."
          docker run --rm "$IMAGE" -c "import json, hashlib, http.client; print('stdlib OK')"
          echo "Verifying no shell..."
          docker run --rm --entrypoint /bin/sh "$IMAGE" -c "echo fail" 2>/dev/null \
            && echo "::error::Shell found in image!" && exit 1 \
            || echo "No shell confirmed"

      - name: Publish Python image
        if: github.event_name != 'pull_request'
        run: |
          apko publish python/apko/python.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-python:latest \
            --arch x86_64

      - name: Sign image with cosign
        if: github.event_name != 'pull_request'
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            cosign sign --yes \
              ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-python:latest

  #----------------------------------------------------------------------------
  # JENKINS IMAGE (melange jlink JRE + WAR + apko, shell-less)
  #----------------------------------------------------------------------------
  build-jenkins:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install melange and apko
        run: |
          go install chainguard.dev/melange@latest
          go install chainguard.dev/apko@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Setup cosign
        uses: sigstore/cosign-installer@v3

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate melange signing key
        run: melange keygen

      - name: Build Jenkins with melange (jlink JRE + WAR)
        run: |
          melange build jenkins/melange.yaml \
            --arch x86_64 \
            --signing-key melange.rsa \
            --out-dir ./packages \
            --runner docker

      - name: Build Jenkins image with apko
        run: |
          apko build jenkins/apko/jenkins.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-jenkins:${{ github.sha }} \
            jenkins.tar \
            --arch x86_64 \
            --repository-append ./packages \
            --keyring-append ${{ github.workspace }}/melange.rsa.pub
          docker load < jenkins.tar
          # Tag the loaded image with our expected tag
          LOADED_IMAGE=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep minimal-jenkins | head -1)
          docker tag "$LOADED_IMAGE" ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-jenkins:${{ github.sha }}

      - name: Report image size
        run: |
          echo "## Jenkins Image Size" >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | \
            grep minimal-jenkins >> $GITHUB_STEP_SUMMARY || true

      - name: Scan Jenkins image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-jenkins:${{ github.sha }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          exit-code: '0'
          cache: 'false'

      - name: Fail on CVEs
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-jenkins:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-jenkins.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
          cache: 'false'

      - name: Upload scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'trivy-jenkins.sarif'

      - name: Test Jenkins image
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-jenkins:${{ github.sha }}"
          echo "Testing Java version..."
          docker run --rm --entrypoint /usr/bin/java "$IMAGE" -version
          echo "Testing Jenkins WAR..."
          docker run --rm --entrypoint /usr/bin/java "$IMAGE" \
            -jar /usr/share/jenkins/jenkins.war --version
          echo "Verifying no shell..."
          docker run --rm --entrypoint /bin/sh "$IMAGE" -c "echo fail" 2>/dev/null \
            && echo "::error::Shell found in image!" && exit 1 \
            || echo "No shell confirmed"
          echo "Verifying git is present..."
          docker run --rm --entrypoint /usr/bin/git "$IMAGE" --version
          echo "Verifying core utils..."
          docker run --rm --entrypoint /bin/ls "$IMAGE" /usr/bin/java

      - name: Publish Jenkins image
        if: github.event_name != 'pull_request'
        run: |
          apko publish jenkins/apko/jenkins.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-jenkins:latest \
            --arch x86_64 \
            --repository-append ./packages \
            --keyring-append ${{ github.workspace }}/melange.rsa.pub

      - name: Sign image with cosign
        if: github.event_name != 'pull_request'
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            cosign sign --yes \
              ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-jenkins:latest

  #----------------------------------------------------------------------------
  # NODE.JS IMAGE (Wolfi package + apko) - Fast build using pre-built package
  #----------------------------------------------------------------------------
  build-node:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install apko
        run: |
          go install chainguard.dev/apko@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Setup cosign
        uses: sigstore/cosign-installer@v3

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Node.js image with apko
        run: |
          apko build node/apko/node.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-node:${{ github.sha }} \
            node.tar \
            --arch x86_64
          docker load < node.tar
          LOADED_IMAGE=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep minimal-node | head -1)
          docker tag "$LOADED_IMAGE" ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-node:${{ github.sha }}

      - name: Report image size
        run: |
          echo "## Node Image Size" >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | \
            grep minimal-node >> $GITHUB_STEP_SUMMARY || true

      - name: Scan Node.js image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-node:${{ github.sha }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          exit-code: '0'
          cache: 'false'

      - name: Fail on CVEs
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-node:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-node.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
          cache: 'false'

      - name: Upload scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'trivy-node.sarif'

      - name: Test Node.js image
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-node:${{ github.sha }}"
          echo "Testing Node version..."
          docker run --rm "$IMAGE" --version
          echo "Testing simple script..."
          docker run --rm "$IMAGE" -e 'console.log("Hello minimal node")'
          echo "Verifying no shell..."
          docker run --rm --entrypoint /bin/sh "$IMAGE" -c "echo fail" 2>/dev/null \
            && echo "::error::Shell found in image!" && exit 1 \
            || echo "No shell confirmed"

      - name: Publish Node.js image
        if: github.event_name != 'pull_request'
        run: |
          apko publish node/apko/node.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-node:latest \
            --arch x86_64

      - name: Sign image with cosign
        if: github.event_name != 'pull_request'
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            cosign sign --yes \
              ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-node:latest

  #----------------------------------------------------------------------------
  # GO IMAGE (Wolfi package + apko, with build tools)
  #----------------------------------------------------------------------------
  build-go:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install apko
        run: |
          go install chainguard.dev/apko@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Setup cosign
        uses: sigstore/cosign-installer@v3

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Go image with apko
        run: |
          apko build go/apko/go.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-go:${{ github.sha }} \
            go.tar \
            --arch x86_64
          docker load < go.tar
          LOADED_IMAGE=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep minimal-go | head -1)
          docker tag "$LOADED_IMAGE" ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-go:${{ github.sha }}

      - name: Report image size
        run: |
          echo "## Go Image Size" >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | \
            grep minimal-go >> $GITHUB_STEP_SUMMARY || true

      - name: Scan Go image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-go:${{ github.sha }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          exit-code: '0'
          cache: 'false'

      - name: Fail on CVEs
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-go:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-go.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
          cache: 'false'

      - name: Upload scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'trivy-go.sarif'

      - name: Test Go image
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-go:${{ github.sha }}"
          echo "Testing Go version..."
          docker run --rm "$IMAGE" version
          echo "Testing Go build tools..."
          docker run --rm --entrypoint /usr/bin/gcc "$IMAGE" --version | head -1
          docker run --rm --entrypoint /usr/bin/make "$IMAGE" --version
          echo "Testing git..."
          docker run --rm --entrypoint /usr/bin/git "$IMAGE" --version
          echo "Testing simple Go program..."
          echo 'package main; import "fmt"; func main() { fmt.Println("Hello from minimal-go") }' > /tmp/test.go
          docker run --rm -v /tmp:/app -w /app "$IMAGE" run test.go || echo "Note: Go run test completed"
          echo "Verifying no shell..."
          docker run --rm --entrypoint /bin/sh "$IMAGE" -c "echo fail" 2>/dev/null \
            && echo "::error::Shell found in image!" && exit 1 \
            || echo "No shell confirmed"

      - name: Publish Go image
        if: github.event_name != 'pull_request'
        run: |
          apko publish go/apko/go.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-go:latest \
            --arch x86_64

      - name: Sign image with cosign
        if: github.event_name != 'pull_request'
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            cosign sign --yes \
              ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-go:latest

  #----------------------------------------------------------------------------
  # NGINX IMAGE (Wolfi package + apko, shell-less)
  #----------------------------------------------------------------------------
  build-nginx:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install apko
        run: |
          go install chainguard.dev/apko@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Setup cosign
        uses: sigstore/cosign-installer@v3

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Nginx image with apko
        run: |
          apko build nginx/apko/nginx.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-nginx:${{ github.sha }} \
            nginx.tar \
            --arch x86_64
          docker load < nginx.tar
          LOADED_IMAGE=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep minimal-nginx | head -1)
          docker tag "$LOADED_IMAGE" ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-nginx:${{ github.sha }}

      - name: Report image size
        run: |
          echo "## Nginx Image Size" >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | \
            grep minimal-nginx >> $GITHUB_STEP_SUMMARY || true

      - name: Scan Nginx image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-nginx:${{ github.sha }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          exit-code: '0'
          cache: 'false'

      - name: Fail on CVEs
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-nginx:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-nginx.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
          cache: 'false'

      - name: Upload scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'trivy-nginx.sarif'

      - name: Test Nginx image
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-nginx:${{ github.sha }}"
          echo "Testing Nginx starts..."
          docker run -d --name nginx-test "$IMAGE"
          sleep 2
          if docker ps | grep -q nginx-test; then
            echo "Nginx is running"
            docker logs nginx-test
            docker stop nginx-test && docker rm nginx-test
          else
            echo "Nginx failed to start, checking logs..."
            docker logs nginx-test 2>&1 || true
            docker rm nginx-test 2>/dev/null || true
            exit 1
          fi
          echo "Verifying no shell..."
          docker run --rm --entrypoint /bin/sh "$IMAGE" -c "echo fail" 2>/dev/null \
            && echo "::error::Shell found in image!" && exit 1 \
            || echo "No shell confirmed"

      - name: Publish Nginx image
        if: github.event_name != 'pull_request'
        run: |
          apko publish nginx/apko/nginx.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-nginx:latest \
            --arch x86_64

      - name: Sign image with cosign
        if: github.event_name != 'pull_request'
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            cosign sign --yes \
              ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-nginx:latest

  #----------------------------------------------------------------------------
  # HTTPD IMAGE (Wolfi package + apko, shell-less)
  #----------------------------------------------------------------------------
  build-httpd:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install apko
        run: |
          go install chainguard.dev/apko@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Setup cosign
        uses: sigstore/cosign-installer@v3

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build HTTPD image with apko
        run: |
          apko build httpd/apko/httpd.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-httpd:${{ github.sha }} \
            httpd.tar \
            --arch x86_64
          docker load < httpd.tar
          LOADED_IMAGE=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep minimal-httpd | head -1)
          docker tag "$LOADED_IMAGE" ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-httpd:${{ github.sha }}

      - name: Report image size
        run: |
          echo "## HTTPD Image Size" >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | \
            grep minimal-httpd >> $GITHUB_STEP_SUMMARY || true

      - name: Scan HTTPD image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-httpd:${{ github.sha }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          exit-code: '0'
          cache: 'false'

      - name: Fail on CVEs
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-httpd:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-httpd.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
          cache: 'false'

      - name: Upload scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'trivy-httpd.sarif'

      - name: Test HTTPD image
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-httpd:${{ github.sha }}"
          echo "Testing HTTPD starts..."
          # The image entrypoint already sets ServerName and a writable PidFile.
          # Just start the container and verify it comes up.
          docker run -d --name httpd-test "$IMAGE"
          sleep 2
          if docker ps | grep -q httpd-test; then
            echo "HTTPD is running"
            docker logs httpd-test
            docker stop httpd-test && docker rm httpd-test
          else
            echo "HTTPD failed to start, checking logs..."
            docker logs httpd-test 2>&1 || true
            docker rm httpd-test 2>/dev/null || true
            exit 1
          fi
          # Some httpd/Wolfi dependency chains can bring a minimal /bin/sh.
          # We treat shell presence as informational for httpd (we still gate on CVEs + startup).
          echo "Checking for shell presence (informational)..."
          if docker run --rm --entrypoint /bin/sh "$IMAGE" -c "true" 2>/dev/null; then
            echo "::notice::/bin/sh is present in minimal-httpd (not treated as failure)"
          else
            echo "No /bin/sh found (shell-less)"
          fi

      - name: Publish HTTPD image
        if: github.event_name != 'pull_request'
        run: |
          apko publish httpd/apko/httpd.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-httpd:latest \
            --arch x86_64

      - name: Sign image with cosign
        if: github.event_name != 'pull_request'
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            cosign sign --yes \
              ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-httpd:latest

  #----------------------------------------------------------------------------
  # REDIS SLIM IMAGE (melange source build + apko)
  #----------------------------------------------------------------------------
  build-redis-slim:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install melange and apko
        run: |
          go install chainguard.dev/melange@latest
          go install chainguard.dev/apko@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Setup cosign
        uses: sigstore/cosign-installer@v3

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate melange signing key
        run: melange keygen

      - name: Build Redis with melange (from source)
        run: |
          melange build redis-slim/melange.yaml \
            --arch x86_64 \
            --signing-key melange.rsa \
            --out-dir ./packages \
            --runner docker

      - name: Build Redis Slim image with apko
        run: |
          apko build redis-slim/apko/redis.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-redis-slim:${{ github.sha }} \
            redis-slim.tar \
            --arch x86_64 \
            --repository-append ./packages \
            --keyring-append ${{ github.workspace }}/melange.rsa.pub
          docker load < redis-slim.tar
          LOADED_IMAGE=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep minimal-redis-slim | head -1)
          docker tag "$LOADED_IMAGE" ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-redis-slim:${{ github.sha }}

      - name: Report image size
        run: |
          echo "## Redis Slim Image Size" >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | \
            grep minimal-redis-slim >> $GITHUB_STEP_SUMMARY || true

      - name: Scan Redis Slim image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-redis-slim:${{ github.sha }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          exit-code: '0'
          cache: 'false'

      - name: Fail on CVEs
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-redis-slim:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-redis-slim.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
          cache: 'false'

      - name: Upload scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'trivy-redis-slim.sarif'

      - name: Test Redis Slim image
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-redis-slim:${{ github.sha }}"
          echo "Testing Redis starts..."
          docker run -d --name redis-test "$IMAGE"
          sleep 2
          if docker ps | grep -q redis-test; then
            echo "Redis is running"
            docker logs redis-test
            docker stop redis-test && docker rm redis-test
          else
            echo "Redis failed to start, checking logs..."
            docker logs redis-test 2>&1 || true
            docker rm redis-test 2>/dev/null || true
            exit 1
          fi
          echo "Testing Redis CLI..."
          docker run -d --name redis-cli-test "$IMAGE"
          sleep 2
          docker run --rm --link redis-cli-test:redis --entrypoint /usr/bin/redis-cli "$IMAGE" -h redis PING
          docker stop redis-cli-test && docker rm redis-cli-test

      - name: Publish Redis Slim image
        if: github.event_name != 'pull_request'
        run: |
          apko publish redis-slim/apko/redis.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-redis-slim:latest \
            --arch x86_64 \
            --repository-append ./packages \
            --keyring-append ${{ github.workspace }}/melange.rsa.pub

      - name: Sign image with cosign
        if: github.event_name != 'pull_request'
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            cosign sign --yes \
              ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-redis-slim:latest

  #----------------------------------------------------------------------------
  # POSTGRES SLIM IMAGE (Wolfi package + apko)
  #----------------------------------------------------------------------------
  build-postgres-slim:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install apko
        run: |
          go install chainguard.dev/apko@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Setup cosign
        uses: sigstore/cosign-installer@v3

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Postgres Slim image with apko
        run: |
          apko build postgres-slim/apko/postgres.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-postgres-slim:${{ github.sha }} \
            postgres-slim.tar \
            --arch x86_64
          docker load < postgres-slim.tar
          LOADED_IMAGE=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep minimal-postgres-slim | head -1)
          docker tag "$LOADED_IMAGE" ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-postgres-slim:${{ github.sha }}

      - name: Report image size
        run: |
          echo "## Postgres Slim Image Size" >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | \
            grep minimal-postgres-slim >> $GITHUB_STEP_SUMMARY || true

      - name: Scan Postgres Slim image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-postgres-slim:${{ github.sha }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          exit-code: '0'
          cache: 'false'

      - name: Fail on CVEs
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-postgres-slim:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-postgres-slim.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
          cache: 'false'

      - name: Upload scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'trivy-postgres-slim.sarif'

      - name: Test Postgres Slim image
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-postgres-slim:${{ github.sha }}"
          echo "Testing PostgreSQL version..."
          docker run --rm --entrypoint /usr/bin/postgres "$IMAGE" --version
          echo "Testing psql client..."
          docker run --rm --entrypoint /usr/bin/psql "$IMAGE" --version
          echo "Testing PostgreSQL starts..."
          docker run -d --name postgres-test \
            -e POSTGRES_HOST_AUTH_METHOD=trust \
            --entrypoint "" "$IMAGE" \
            sh -c "initdb -D /var/lib/postgresql/data && postgres -D /var/lib/postgresql/data -h 0.0.0.0" || true
          sleep 5
          if docker ps | grep -q postgres-test; then
            echo "PostgreSQL is running"
            docker logs postgres-test 2>&1 | tail -5
            docker stop postgres-test && docker rm postgres-test
          else
            echo "PostgreSQL startup check (informational)..."
            docker logs postgres-test 2>&1 || true
            docker rm postgres-test 2>/dev/null || true
          fi

      - name: Publish Postgres Slim image
        if: github.event_name != 'pull_request'
        run: |
          apko publish postgres-slim/apko/postgres.yaml \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-postgres-slim:latest \
            --arch x86_64

      - name: Sign image with cosign
        if: github.event_name != 'pull_request'
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            cosign sign --yes \
              ${{ env.REGISTRY }}/${{ github.repository_owner }}/minimal-postgres-slim:latest

  #----------------------------------------------------------------------------
  # SUMMARY
  #----------------------------------------------------------------------------
  summary:
    needs: [build-python, build-jenkins, build-node, build-go, build-nginx, build-httpd, build-redis-slim, build-postgres-slim]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Check results
        run: |
          if [ "${{ needs.build-python.result }}" != "success" ] || \
             [ "${{ needs.build-jenkins.result }}" != "success" ] || \
             [ "${{ needs.build-node.result }}" != "success" ] || \
             [ "${{ needs.build-go.result }}" != "success" ] || \
             [ "${{ needs.build-nginx.result }}" != "success" ] || \
             [ "${{ needs.build-httpd.result }}" != "success" ] || \
             [ "${{ needs.build-redis-slim.result }}" != "success" ] || \
             [ "${{ needs.build-postgres-slim.result }}" != "success" ]; then
            echo "::error::One or more images failed"
            exit 1
          fi
          echo "All hardened images built successfully!"

  #----------------------------------------------------------------------------
  # CLEANUP OLD VERSIONS
  #----------------------------------------------------------------------------
  cleanup:
    needs: [build-python, build-jenkins, build-node, build-go, build-nginx, build-httpd, build-redis-slim, build-postgres-slim]
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    permissions:
      packages: write
    steps:
      - name: Delete old Python versions
        uses: actions/delete-package-versions@v5
        with:
          package-name: minimal-python
          package-type: 'container'
          min-versions-to-keep: 10
          delete-only-untagged-versions: 'true'

      - name: Delete old Jenkins versions
        uses: actions/delete-package-versions@v5
        with:
          package-name: minimal-jenkins
          package-type: 'container'
          min-versions-to-keep: 10
          delete-only-untagged-versions: 'true'

      - name: Delete old Node versions
        uses: actions/delete-package-versions@v5
        with:
          package-name: minimal-node
          package-type: 'container'
          min-versions-to-keep: 10
          delete-only-untagged-versions: 'true'

      - name: Delete old Go versions
        uses: actions/delete-package-versions@v5
        with:
          package-name: minimal-go
          package-type: 'container'
          min-versions-to-keep: 10
          delete-only-untagged-versions: 'true'

      - name: Delete old Nginx versions
        uses: actions/delete-package-versions@v5
        with:
          package-name: minimal-nginx
          package-type: 'container'
          min-versions-to-keep: 10
          delete-only-untagged-versions: 'true'

      - name: Delete old HTTPD versions
        uses: actions/delete-package-versions@v5
        with:
          package-name: minimal-httpd
          package-type: 'container'
          min-versions-to-keep: 10
          delete-only-untagged-versions: 'true'

      - name: Delete old Redis Slim versions
        uses: actions/delete-package-versions@v5
        with:
          package-name: minimal-redis-slim
          package-type: 'container'
          min-versions-to-keep: 10
          delete-only-untagged-versions: 'true'

      - name: Delete old Postgres Slim versions
        uses: actions/delete-package-versions@v5
        with:
          package-name: minimal-postgres-slim
          package-type: 'container'
          min-versions-to-keep: 10
          delete-only-untagged-versions: 'true'
